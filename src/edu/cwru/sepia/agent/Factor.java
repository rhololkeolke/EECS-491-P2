package edu.cwru.sepia.agent;

import java.util.ArrayList;
import java.util.List;

import edu.cwru.sepia.action.TargetedAction;
import edu.cwru.sepia.environment.model.history.History.HistoryView;
import edu.cwru.sepia.environment.model.state.State.StateView;
import edu.cwru.sepia.agent.mock.LearningUnit;

public class Factor {
	
	private LearningUnit max;
	private LearningUnit agent;
	private Factor f;
	
	private List<Tuple<TargetedAction, Double>> JTable;

	// for now this method assumes that there will be at most 2 edges for every node in the graph
	// so it only needs to accept a single agent and a single factor
	public Factor(StateView s, HistoryView h, int playernum, LearningUnit max, LearningUnit agent, Factor f)
	{
		// stores the J values of all the possible actions for the agent currently being
		// maximized
		List<Tuple<TargetedAction, Double>> maxJTable = max.calcJTable(s, h, playernum);
		
		// get the J values of all the possible actions for the agent
		List<Tuple<TargetedAction, Double>> agentJTable = agent.calcJTable(s, h, playernum);

		List<Tuple<TargetedAction, Double>> intermediateTable1 = constructIntermediateTable(maxJTable, agentJTable);
		
		List<Tuple<TargetedAction, Double>> intermediateTable2 = constructIntermediateTable(maxJTable, f.getJTable());
		
		List<Tuple<TargetedAction, Double>> jointActionTable = constructJointActionTable(maxJTable.size(), intermediateTable1, intermediateTable2);
		
		JTable = compressJointActionTable(maxJTable.size(), 2, jointActionTable);

	}
	
	// this method is used when there is no factor, just a single J function
	public Factor(StateView s, HistoryView h, int playernum, LearningUnit max, LearningUnit agent)
	{
		// stores the J values of all the possible actions for the agent currently being maximized
		List<Tuple<TargetedAction, Double>> maxJTable = max.calcJTable(s, h, playernum);
		
		// get the J values for all the possible actions for the agent
		List<Tuple<TargetedAction, Double>> agentJTable = agent.calcJTable(s, h, playernum);
		
		List<Tuple<TargetedAction, Double>> intermediateTable = constructIntermediateTable(maxJTable, agentJTable);
		
		JTable = compressJointActionTable(maxJTable.size(), 1, intermediateTable);
	}
	
	/* create intermediate action pair tables for each the agent
	 * 
	 * An example of an intermediate action pair table is
	 * 
	 * +--+--+---+
     * |a1|a2|J12|
     * +==+==+===+
     * |A0|A0|4  |
     * +--+--+---+
     * |A0|A1|2  |
     * +--+--+---+
     * |A1|A0|6  |
     * +--+--+---+
     * |A1|A1|8  |
     * +--+--+---+
     * 
     * Where the first two columns select the action for each agent
     * and the third column is the summation of each agents J for the given actions.
     * 
     * It is assumed that a1 will be the agent represented by max
     * and a2 will be whichever agent in agents is currently being
     * processed
     */		
	private List<Tuple<TargetedAction, Double>> constructIntermediateTable(List<Tuple<TargetedAction, Double>> a1JTable,
			                                                           List<Tuple<TargetedAction, Double>> a2JTable)
	{
	
		int numActions = a1JTable.size();
		
		// the number of actions in the intermediate table with two agents
		// is the square of the number of actions (assuming that each agent
		// has the same number of actions)
		List<Tuple<TargetedAction, Double>> intermediateTable = new ArrayList<Tuple<TargetedAction, Double>>(numActions*numActions);
		
		Double[] jVals = new Double[numActions*numActions];
		TargetedAction[] actions = new TargetedAction[numActions*numActions];
		
		// think of these loops as constructing a truth table except
		// now there may be more than actions for each agent
		// (i.e. no longer just True and False)
		for(int i=0; i<a1JTable.size(); i++) 
		{
			Tuple<TargetedAction, Double> maxJVal = a1JTable.get(i); // convenience variable which saves some typing
			for(int j=0; j<a2JTable.size(); j++)
			{
				// get the index into the intermediate table
				int index = i*numActions + j;
				jVals[index] = maxJVal.second + a2JTable.get(j).second;
				actions[index] = a1JTable.get(i).first;
			}
		}
		
		for(int i=0; i<jVals.length; i++)
		{
			intermediateTable.add(new Tuple<TargetedAction, Double>(actions[i], jVals[i]));
		}
		
		return intermediateTable;
	}
	
	public List<Tuple<TargetedAction, Double>> getJTable()
	{
		return JTable;
	}

	/*
	 * Takes in two intermediate tables and combines them into a single table
	 * 
	 * For instance an intermediate table for a1, a2 and an intermediate table for
	 * a1 and a3 are combined to look like the following
	 * 
	 * +==+==+==+=+
	 * |a1|a2|a3|J|
	 * +==+==+==+=+
	 * |A0|A0|A0|3|
	 * +--+--+--+-+
	 * |A0|A0|A1|7|
	 * +--+--+--+-+
	 * |..........|
	 * +--+--+--+-+
	 * |A1|A1|A0|2|
	 * +--+--+--+-+
	 * |A1|A1|A1|9|
	 * +--+--+--+-+
	 * 
	 * However, only the J value of each row is stored.
	 * The rest of the information can be reconstructed from the index
	 * of J.
	 */
	private List<Tuple<TargetedAction, Double>> constructJointActionTable(int numActions,
			                                   List<Tuple<TargetedAction, Double>> table1,
			                                   List<Tuple<TargetedAction, Double>> table2)
	{
		Double[] JVals = new Double[numActions*numActions*numActions];
		TargetedAction[] actions = new TargetedAction[numActions*numActions*numActions];
		
		for(int i=0; i<table1.size(); i++)
		{
			for(int j=0; j<table2.size(); j++)
			{
				if(i/numActions == j/numActions)
				{
					// the index is essentially like converting from a number in the base of Action to a number in decimal
					int index = (i/numActions)*numActions*numActions + (i % numActions)*numActions + (i % numActions);
					JVals[index] = table1.get(i).second + table2.get(j).second;
					actions[index] = table1.get(i).first;
				}
			}
		}
		
		List<Tuple<TargetedAction, Double>> jointJTable = new ArrayList<Tuple<TargetedAction, Double>>(JVals.length);
		for(int i=0; i<JVals.length; i++)
		{
			TargetedAction action = actions[i];
			jointJTable.add(new Tuple<TargetedAction, Double>(actions[i], JVals[i]));
		}
		return jointJTable;
	}
	
	/*
	 * Go through a table and find the maximum over the max agent
	 */
	private List<Tuple<TargetedAction, Double>> compressJointActionTable(int numActions, int dim, List<Tuple<TargetedAction, Double>> finalActionTable)
	{
		Double[] JVals = new Double[numActions];
		TargetedAction[] actions = new TargetedAction[numActions];
		
		for(int i=0; i<(int)Math.pow(numActions, dim); i++)
		{
			// find max out of possible values of max agent's action
			JVals[i] = Double.NEGATIVE_INFINITY;
			for(int j=0; j<numActions; j++)
			{
				int index = i + j*(int)Math.pow(numActions, dim);
				if(JVals[i] < finalActionTable.get(index).second) // if found a new best number
				{
					// update everything
					JVals[i] = finalActionTable.get(index).second;
					actions[i] = finalActionTable.get(i).first;
				}
			}
		}
		
		// finally construct the final table
		List<Tuple<TargetedAction, Double>> finalJTable = new ArrayList<Tuple<TargetedAction, Double>>(JVals.length);
		for(int i=0; i<JVals.length; i++)
		{
			finalJTable.add(new Tuple<TargetedAction, Double>(actions[i], JVals[i]));
		}
		return finalJTable;
	}
	
	public void update(Factor f)
	{
		// TODO implement this method
		// The method is supposed to take in a factor
		// and using that factor compress the internal table
	}
	
	public TargetedAction selectActions()
	{
		// TODO implement this method
		// this method is supposed to return the
		// maximum action over the actions left in the JTable
		return null;
	}
}
